<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GameHub - Car 3D Simulator</title>
    <style>
        html,body{height:100%;margin:0}
        #sceneWrap{width:100%;height:100vh;display:flex;flex-direction:column}
        #canvasContainer{flex:1;position:relative}
        #ui{position:absolute;top:12px;left:12px;z-index:10;background:rgba(255,255,255,0.9);padding:10px;border-radius:8px}
        button{margin:6px;padding:8px 12px;border-radius:6px;border:none;background:#667eea;color:#fff}
        .hint{font-size:13px;margin-top:6px}
    </style>
</head>
<body>
    <div id="sceneWrap">
        <div id="canvasContainer">
            <div id="ui">
                <button onclick="startSim()">Start</button>
                <button onclick="resetSim()">Reset</button>
                <button onclick="goBack()">‚Üê Back</button>
                <div class="hint">Controls: W/S accelerate, A/D steer, Space brake</div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script>
        let scene, camera, renderer, car, clock;
        let keys = {};
        let carState = { speed: 0, angle: 0, position: new THREE.Vector3(0,0.5,0) };
        const maxSpeed = 12;
        const accel = 20;
        const steerSpeed = 2.5;
        const friction = 4;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfd1e5);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvasContainer').appendChild(renderer.domElement);

            // Lights
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            hemi.position.set(0, 200, 0);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5,10,7);
            scene.add(dir);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(400, 400);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI/2;
            scene.add(ground);

            // Simple track markings
            const lineGeo = new THREE.PlaneGeometry(1, 400);
            const lineMat = new THREE.MeshBasicMaterial({ color:0xffffff });
            for(let i=-6;i<=6;i+=2){
                const l = new THREE.Mesh(lineGeo, lineMat);
                l.rotation.x = -Math.PI/2;
                l.position.set(i*2,0.01,0);
                scene.add(l);
            }

            // Car (box)
            const carGeo = new THREE.BoxGeometry(1.2,0.6,2.2);
            const carMat = new THREE.MeshStandardMaterial({ color:0xff4444 });
            car = new THREE.Mesh(carGeo, carMat);
            car.position.copy(carState.position);
            car.castShadow = true;
            scene.add(car);

            // simple wheels (visual)
            const wheelGeo = new THREE.CylinderGeometry(0.25,0.25,0.4,12);
            const wheelMat = new THREE.MeshStandardMaterial({ color:0x222222 });
            const offsets = [[0.6,-0.25,0.9],[ -0.6,-0.25,0.9],[0.6,-0.25,-0.9],[-0.6,-0.25,-0.9]];
            offsets.forEach(o=>{
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.rotation.z = Math.PI/2;
                w.position.set(o[0],o[1],o[2]);
                car.add(w);
            });

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
            window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

            clock = new THREE.Clock();
        }

        function onResize(){
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let running = false;
        function startSim(){ if(!running){ running=true; clock.start(); animate(); }}
        function resetSim(){ running=false; carState = { speed:0, angle:0, position: new THREE.Vector3(0,0.5,0) }; car.position.copy(carState.position); car.rotation.y = 0; camera.position.set(0,6,-10); camera.lookAt(car.position); render(); }

        function animate(){
            if(!running) return;
            const dt = Math.min(0.05, clock.getDelta());

            // Input
            let forward = keys['w']?1: (keys['s']?-1:0);
            let steer = keys['a']?-1: (keys['d']?1:0);
            const brake = keys[' '];

            // update speed
            if(forward !== 0){
                carState.speed += forward * accel * dt;
            } else {
                // natural friction
                if(carState.speed>0) carState.speed = Math.max(0, carState.speed - friction*dt);
                if(carState.speed<0) carState.speed = Math.min(0, carState.speed + friction*dt);
            }

            // brake
            if(brake) carState.speed *= 0.95;

            // clamp speed
            carState.speed = Math.max(-maxSpeed/2, Math.min(maxSpeed, carState.speed));

            // steering affects angle based on speed
            carState.angle += steer * steerSpeed * dt * (carState.speed/Math.max(1, maxSpeed/3));

            // update position using angle
            const forwardVec = new THREE.Vector3(Math.sin(carState.angle), 0, Math.cos(carState.angle));
            carState.position.addScaledVector(forwardVec, carState.speed * dt);

            // apply to mesh
            car.position.copy(carState.position);
            car.rotation.y = carState.angle;

            // camera follow
            const camOffset = new THREE.Vector3(0,4,-8).applyAxisAngle(new THREE.Vector3(0,1,0), carState.angle);
            const camPos = car.position.clone().add(camOffset);
            camera.position.lerp(camPos, 0.12);
            camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1,0)));

            render();
            requestAnimationFrame(animate);
        }

        function render(){ renderer.render(scene, camera); }

        function goBack(){ window.location.href='index.html'; }

        // Initialize
        init();
        render();
    </script>
<script src="shared.js"></script>
</body>
</html>