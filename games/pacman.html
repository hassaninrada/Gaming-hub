<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Pacman 2.0 | GameHub Pro</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        .game-wrapper {
            max-width: 700px;
            margin: 40px auto;
            background: var(--card-bg);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 40px 100px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
        }

        .stats-bar {
            padding: 15px 40px;
            background: rgba(124, 77, 255, 0.1);
            display: flex;
            justify-content: space-around;
            font-size: 14px;
            font-weight: 800;
            border-bottom: 1px solid var(--glass-border);
        }

        .stat-val {
            color: var(--accent-secondary);
            margin-left: 5px;
            font-size: 18px;
        }

        .game-body {
            position: relative;
            background: #000;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        canvas {
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .game-controls {
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.2);
        }

        .overlay-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: 900;
            color: #ffea00;
            text-shadow: 0 0 20px rgba(255, 234, 0, 0.5);
            display: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 12px;
            border: 2px solid #ffea00;
        }
    </style>
</head>

<body class="dark-theme">
    <div class="bg-glow-container">
        <div class="glow-sphere sphere-1"></div>
        <div class="glow-sphere sphere-2"></div>
    </div>

    <header class="main-header" style="position: relative; background: transparent; border: none;">
        <div class="nav-container">
            <a href="../index.html" class="logo" style="text-decoration: none; color: inherit;">
                <i data-lucide="arrow-left"></i>
                <span>BACK TO <span class="accent-text">HUB</span></span>
            </a>
            <h2 style="font-weight:800; letter-spacing:-1px">CYBER PACMAN 2.0</h2>
        </div>
    </header>

    <div class="game-wrapper">
        <div class="stats-bar">
            <span>SCORE: <span class="stat-val" id="score">0</span></span>
            <span>LIVES: <span class="stat-val" id="lives">3</span></span>
        </div>

        <div class="game-body">
            <canvas id="gameCanvas" width="441" height="441"></canvas>
            <div class="overlay-msg" id="msgOverlay">READY?</div>
        </div>

        <div class="game-controls">
            <p style="color:#aaa; font-size:12px; letter-spacing:1px">ARROWS TO MOVE</p>
        </div>
    </div>

    <script src="../js/shared.js"></script>
    <script>
        lucide.createIcons();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BLOCK = 21; // Cell Size
        const ROWS = 21;
        const COLS = 21;

        // 1=Wall, 0=Dot, 2=Empty, 3=Power, 4=Gate
        const MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 3, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 3, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 0, 1, 1, 1, 2, 1, 2, 1, 1, 1, 0, 1, 1, 1, 1, 1],
            [2, 2, 2, 2, 1, 0, 1, 2, 2, 2, 4, 2, 2, 2, 1, 0, 1, 2, 2, 2, 2],
            [1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 2, 1, 1, 2, 1, 0, 1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2, 0, 2, 2, 1, 2, 2, 2, 1, 2, 2, 0, 2, 2, 2, 2, 2],
            [1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 1, 1, 1, 2, 1, 0, 1, 1, 1, 1, 1],
            [2, 2, 2, 2, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1, 0, 1, 2, 2, 2, 2],
            [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 1],
            [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];
        // Note: Map height adjusted to fit logic or array checks
        // Actually defined 19 rows in array, let's fix canvas height or logic
        // Canvas is 441/21 = 21 cols. Array has 21 cols.
        // Rows: array has 19. Let's add 2 rows.

        while (MAP.length < 21) {
            MAP.push([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
        }

        let player = { x: 10, y: 15, dir: 4, nextDir: 4, frame: 0 }; // dir: 0=up, 1=right, 2=down, 3=left, 4=stop
        let ghosts = [
            { x: 9, y: 9, color: '#ff0000', dir: 1, mode: 'chase' },
            { x: 10, y: 9, color: '#ffb8ff', dir: 3, mode: 'chase' },
            { x: 11, y: 9, color: '#00ffff', dir: 0, mode: 'ambush' },
            { x: 10, y: 8, color: '#ffb852', dir: 2, mode: 'random' }
        ];

        let score = 0;
        let lives = 3;
        let powerTimer = 0;
        let active = false;
        let dots = [];
        let pulses = [];

        function init() {
            // Parse map for dots
            dots = [];
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (MAP[y][x] === 0) dots.push({ x, y, type: 'dot' });
                    if (MAP[y][x] === 3) dots.push({ x, y, type: 'power' });
                }
            }
            resetPositions();
            score = 0;
            lives = 3;
            updateUI();

            showMessage("READY?", () => {
                active = true;
                requestAnimationFrame(loop);
            });
        }

        function resetPositions() {
            player.x = 10; player.y = 15; player.dir = 4; player.nextDir = 4;
            ghosts[0].x = 9; ghosts[0].y = 9;
            ghosts[1].x = 10; ghosts[1].y = 9;
            ghosts[2].x = 11; ghosts[2].y = 9;
            ghosts[3].x = 10; ghosts[3].y = 8;
        }

        function showMessage(txt, cb) {
            let el = document.getElementById('msgOverlay');
            el.innerText = txt;
            el.style.display = 'block';
            setTimeout(() => {
                el.style.display = 'none';
                if (cb) cb();
            }, 2000);
        }

        function canMove(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
            let cell = MAP[y][x];
            return cell !== 1 && cell !== 4; // Not wall
        }

        function moveActor(actor, speed) {
            // This is grid-snap logic simplification for 1 file
            // We assume actors are integers logic-wise but could verify
            // For smoother movement we normally use floats + interpolation.
            // Here we'll stick to 0.1 increments and snap to center.

            // Simplified: Logical update every N frames.
            // Let's do partial updates.
        }

        // Actually, frame-based logic with integer movement 10 steps per tile is best for retro feel.
        let frameCount = 0;

        function update() {
            if (!active) return;
            frameCount++;

            // Player Move (every 5 frames = speed)
            if (frameCount % 5 === 0) {
                // Try turn
                let dx = 0, dy = 0;
                if (player.nextDir === 0) dy = -1;
                if (player.nextDir === 1) dx = 1;
                if (player.nextDir === 2) dy = 1;
                if (player.nextDir === 3) dx = -1;

                if (canMove(player.x + dx, player.y + dy)) {
                    player.dir = player.nextDir;
                }

                // Move current dir
                dx = 0; dy = 0;
                if (player.dir === 0) dy = -1;
                if (player.dir === 1) dx = 1;
                if (player.dir === 2) dy = 1;
                if (player.dir === 3) dx = -1;

                if (canMove(player.x + dx, player.y + dy)) {
                    player.x += dx;
                    player.y += dy;
                    player.frame++;
                }

                // Eating
                let eatenIdx = dots.findIndex(d => d.x === player.x && d.y === player.y && d.active !== false);
                if (eatenIdx !== -1) {
                    let d = dots[eatenIdx];
                    d.active = false;
                    dots.splice(eatenIdx, 1);
                    if (d.type === 'power') {
                        score += 50;
                        powerTimer = 500; // frames
                        if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('win');
                    } else {
                        score += 10;
                        // small sound
                    }

                    if (dots.length === 0) {
                        active = false;
                        showMessage("YOU WIN!", () => window.location.reload());
                    }
                }
            }

            // Ghost Move (every 6 or 8 frames)
            let gSpeed = powerTimer > 0 ? 10 : 7;
            if (frameCount % gSpeed === 0) {
                ghosts.forEach(g => {
                    // Simple AI: Try to get closer to player if chase, random if random
                    // Or just random valid move not backwards
                    let possible = [];
                    if (canMove(g.x, g.y - 1) && g.dir !== 2) possible.push(0);
                    if (canMove(g.x + 1, g.y) && g.dir !== 3) possible.push(1);
                    if (canMove(g.x, g.y + 1) && g.dir !== 0) possible.push(2);
                    if (canMove(g.x - 1, g.y) && g.dir !== 1) possible.push(3);

                    if (possible.length === 0) {
                        // Dead end, reverse
                        g.dir = (g.dir + 2) % 4;
                    } else {
                        // Pick best
                        if (powerTimer > 0) {
                            // Run away (maximize dist)
                            possible.sort((a, b) => distSq(g, a, player) - distSq(g, b, player)); // Ascending? No we want max.
                            // DistSq returns dist from new pos to player
                            g.dir = possible[0]; // Wait, logic below
                        } else {
                            // Chase (minimize dist)
                            possible.sort((a, b) => distSq(g, a, player) - distSq(g, b, player));
                            g.dir = possible[0];
                        }
                    }

                    if (g.dir === 0) g.y--;
                    if (g.dir === 1) g.x++;
                    if (g.dir === 2) g.y++;
                    if (g.dir === 3) g.x--;

                    // Collision catch
                    if (g.x === player.x && g.y === player.y) {
                        if (powerTimer > 0) {
                            // Eat Ghost
                            g.x = 10; g.y = 9; // Respawn
                            score += 200;
                            if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('win');
                        } else {
                            // Die
                            die();
                        }
                    }
                });
            }

            if (powerTimer > 0) powerTimer--;
            updateUI();
        }

        function distSq(ghost, dir, target) {
            let nx = ghost.x + (dir === 1 ? 1 : (dir === 3 ? -1 : 0));
            let ny = ghost.y + (dir === 2 ? 1 : (dir === 0 ? -1 : 0));
            return (nx - target.x) ** 2 + (ny - target.y) ** 2;
        }

        function die() {
            lives--;
            active = false;
            updateUI();
            if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('loss');

            if (lives <= 0) {
                showMessage("GAME OVER", () => window.location.reload());
            } else {
                showMessage("OUCH!", () => {
                    resetPositions();
                    active = true;
                });
            }
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('lives').innerText = lives;
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Map
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (MAP[y][x] === 1) {
                        ctx.fillStyle = '#111';
                        // Wall lines
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * BLOCK + 4, y * BLOCK + 4, BLOCK - 8, BLOCK - 8);
                    }
                }
            }

            // Dots
            dots.forEach(d => {
                if (d.type === 'power') {
                    ctx.fillStyle = '#ffea00';
                    if (Math.floor(Date.now() / 200) % 2 === 0) {
                        ctx.beginPath(); ctx.arc(d.x * BLOCK + BLOCK / 2, d.y * BLOCK + BLOCK / 2, 6, 0, Math.PI * 2); ctx.fill();
                    }
                } else {
                    ctx.fillStyle = '#ffb8b8';
                    ctx.fillRect(d.x * BLOCK + BLOCK / 2 - 2, d.y * BLOCK + BLOCK / 2 - 2, 4, 4);
                }
            });

            // Player
            ctx.fillStyle = '#ffea00';
            let mouth = (Math.sin(frameCount * 0.5) + 1) * 0.2 + 0.1;
            // Rotation based on dir
            let rot = player.dir * (Math.PI / 2) - Math.PI / 2; // 0=up (-90)
            if (player.dir === 1) rot = 0;
            if (player.dir === 2) rot = Math.PI / 2;
            if (player.dir === 3) rot = Math.PI;
            if (player.dir === 0) rot = -Math.PI / 2;

            ctx.save();
            ctx.translate(player.x * BLOCK + BLOCK / 2, player.y * BLOCK + BLOCK / 2);
            ctx.rotate(rot);
            ctx.beginPath();
            ctx.arc(0, 0, 9, mouth, Math.PI * 2 - mouth);
            ctx.lineTo(0, 0);
            ctx.fill();
            ctx.restore();

            // Ghosts
            ghosts.forEach(g => {
                ctx.fillStyle = powerTimer > 0 ? '#0000ff' : g.color;
                if (powerTimer > 0 && powerTimer < 120 && Math.floor(Date.now() / 100) % 2 === 0) ctx.fillStyle = '#fff'; // flashing

                let gx = g.x * BLOCK + BLOCK / 2;
                let gy = g.y * BLOCK + BLOCK / 2;

                ctx.beginPath();
                ctx.arc(gx, gy - 2, 9, Math.PI, 0);
                ctx.lineTo(gx + 9, gy + 9);
                ctx.lineTo(gx - 9, gy + 9);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(gx - 4, gy - 4, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(gx + 4, gy - 4, 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(gx - 4, gy - 4, 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(gx + 4, gy - 4, 1.5, 0, Math.PI * 2); ctx.fill();
            });
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', e => {
            if (['ArrowUp', 'w'].includes(e.key)) player.nextDir = 0;
            if (['ArrowRight', 'd'].includes(e.key)) player.nextDir = 1;
            if (['ArrowDown', 's'].includes(e.key)) player.nextDir = 2;
            if (['ArrowLeft', 'a'].includes(e.key)) player.nextDir = 3;
        });

        init();
    </script>
</body>

</html>