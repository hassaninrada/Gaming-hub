<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Snake 2.0 | GameHub Pro</title>
  <link rel="stylesheet" href="../css/style.css">
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    .game-wrapper {
      max-width: 800px;
      margin: 40px auto;
      background: var(--card-bg);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 40px 100px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(20px);
    }

    .stats-bar {
      padding: 15px 40px;
      background: rgba(124, 77, 255, 0.1);
      display: flex;
      justify-content: space-around;
      font-size: 14px;
      font-weight: 800;
      border-bottom: 1px solid var(--glass-border);
    }

    .stat-val {
      color: var(--accent-secondary);
      margin-left: 5px;
      font-size: 18px;
    }

    .game-body {
      position: relative;
      background: #050505;
      display: flex;
      justify-content: center;
      padding: 30px;
    }

    canvas {
      border: 2px solid var(--accent-primary);
      box-shadow: 0 0 30px rgba(124, 77, 255, 0.2);
      border-radius: 4px;
      background: radial-gradient(circle at center, #0a0a1a 0%, #000 100%);
    }

    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
  </style>
</head>

<body class="dark-theme">
  <div class="bg-glow-container">
    <div class="glow-sphere sphere-1"></div>
    <div class="glow-sphere sphere-2"></div>
  </div>

  <header class="main-header" style="position: relative; background: transparent; border: none;">
    <div class="nav-container">
      <a href="../index.html" class="logo" style="text-decoration: none; color: inherit;">
        <i data-lucide="arrow-left"></i>
        <span>BACK TO <span class="accent-text">HUB</span></span>
      </a>
      <h2 style="font-weight:800; letter-spacing:-1px">NEON SNAKE 2.0</h2>
    </div>
  </header>

  <div class="game-wrapper">
    <div class="stats-bar">
      <span>SCORE: <span class="stat-val" id="score">0</span></span>
      <span>HIGH: <span class="stat-val" id="highScore">0</span></span>
    </div>

    <div class="game-body">
      <canvas id="gameCanvas" width="600" height="600"></canvas>

      <div class="game-over-overlay" id="gameOver">
        <h1 style="font-size:48px; color:var(--accent-primary); margin-bottom:10px">GAME OVER</h1>
        <p style="margin-bottom:30px; color:#aaa">Score: <span id="finalScore" style="color:#fff">0</span></p>
        <button class="btn-primary" onclick="resetGame()">PLAY AGAIN</button>
      </div>
    </div>
  </div>

  <script src="../js/shared.js"></script>
  <script>
    lucide.createIcons();

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GRID = 20; // 30x30 grid
    const TILE = canvas.width / GRID;

    let snake = [];
    let vel = { x: 0, y: 0 };
    let food = { x: 0, y: 0 };
    let score = 0;
    let active = false;
    let lastTime = 0;
    let accumulator = 0;
    let tickRate = 0.15; // Seconds per move (speed) - Slower default
    let particles = [];

    let highScore = parseInt(localStorage.getItem('snake_high') || '0');
    document.getElementById('highScore').innerText = highScore;

    function resetGame() {
      snake = [{ x: 10, y: 15 }, { x: 9, y: 15 }, { x: 8, y: 15 }];
      vel = { x: 1, y: 0 };
      inputQueue = [];
      score = 0;
      tickRate = 0.15;
      active = true;
      document.getElementById('gameOver').style.display = 'none';
      spawnFood();
      loop();
    }

    function spawnFood() {
      let valid = false;
      while (!valid) {
        food.x = Math.floor(Math.random() * GRID);
        food.y = Math.floor(Math.random() * GRID);
        valid = !snake.some(s => s.x === food.x && s.y === food.y);
      }
    }

    // AI Logic
    let aiMode = false;

    function aiMove() {
      // A* or Simple Greedy? Simple Greedy + Avoid Death for now.
      // Goal: Find path to food

      let bestDir = null;
      let minDist = Infinity;

      const moves = [
        { x: 0, y: -1, k: 'ArrowUp' },
        { x: 0, y: 1, k: 'ArrowDown' },
        { x: -1, y: 0, k: 'ArrowLeft' },
        { x: 1, y: 0, k: 'ArrowRight' }
      ];

      // Filter safe moves
      const head = snake[0];
      let safeMoves = moves.filter(m => {
        let nx = head.x + m.x;
        let ny = head.y + m.y;
        // Wall check
        if (nx < 0 || nx >= GRID || ny < 0 || ny >= GRID) return false;
        // Body check
        if (snake.some(s => s.x === nx && s.y === ny)) return false;
        return true;
      });

      if (safeMoves.length === 0) return; // Doom

      // Greedy: Pick move that gets closer to food
      safeMoves.forEach(m => {
        let nx = head.x + m.x;
        let ny = head.y + m.y;
        let d = Math.abs(nx - food.x) + Math.abs(ny - food.y);
        if (d < minDist) {
          minDist = d;
          bestDir = m;
        }
      });

      // If no getting closer possible (e.g. trapped but has safe moves), Pick random safe
      if (!bestDir && safeMoves.length > 0) bestDir = safeMoves[0];

      if (bestDir) {
        vel = { x: bestDir.x, y: bestDir.y };
      }
    }

    let inputQueue = [];

    window.addEventListener('keydown', e => {
      if (e.key === 'm') {
        aiMode = !aiMode;
        alert("AI MODE: " + (aiMode ? "ON" : "OFF"));
      }

      if (!active) return;

      // Turbo
      if (e.code === 'Space') {
        tickRate = 0.08;
      }

      // Buffer inputs to prevent 180 turns and handle rapid presses
      const lastInput = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : vel;

      if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
        if (lastInput.y === 0) inputQueue.push({ x: 0, y: -1 });
      } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
        if (lastInput.y === 0) inputQueue.push({ x: 0, y: 1 });
      } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
        if (lastInput.x === 0) inputQueue.push({ x: -1, y: 0 });
      } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
        if (lastInput.x === 0) inputQueue.push({ x: 1, y: 0 });
      }
    });

    function update(dt) {
      if (!active) return;

      if (aiMode) aiMove();

      accumulator += dt;
      if (accumulator > tickRate) {
        accumulator -= tickRate;

        // Apply Buffered Input
        if (inputQueue.length > 0) {
          vel = inputQueue.shift();
        }

        // Move Head
        const head = { x: snake[0].x + vel.x, y: snake[0].y + vel.y };

        // Screen Wrapping (Pac-man mode)
        if (head.x < 0) head.x = GRID - 1;
        if (head.x >= GRID) head.x = 0;
        if (head.y < 0) head.y = GRID - 1;
        if (head.y >= GRID) head.y = 0;

        // Self Collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
          if (aiMode) { resetGame(); return; }
          die(); return;
        }

        snake.unshift(head);

        // Eat Food
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          if (score > highScore) localStorage.setItem('snake_high', score);
          tickRate = Math.max(0.06, tickRate * 0.99); // Slower speed up
          if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('win'); // Eat sound

          // Particles
          for (let i = 0; i < 10; i++) {
            particles.push({
              x: (food.x * TILE) + TILE / 2,
              y: (food.y * TILE) + TILE / 2,
              vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
              life: 1.0, color: '#00ff00'
            });
          }

          spawnFood();
        } else {
          snake.pop();
        }
      }
    }

    function die() {
      active = false;
      document.getElementById('finalScore').innerText = score;
      document.getElementById('gameOver').style.display = 'flex';
      if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('loss');
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#050505';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw Grid (Subtle)
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID; i++) {
        ctx.beginPath(); ctx.moveTo(i * TILE, 0); ctx.lineTo(i * TILE, canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i * TILE); ctx.lineTo(canvas.width, i * TILE); ctx.stroke();
      }

      // Pulsating Food
      const pulse = Math.sin(Date.now() / 200) * 2;
      ctx.fillStyle = '#00ff00';
      ctx.shadowBlur = 15 + pulse * 2;
      ctx.shadowColor = '#00ff00';
      ctx.beginPath();
      ctx.arc((food.x + 0.5) * TILE, (food.y + 0.5) * TILE, (TILE / 3) + (pulse / 2), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw Snake
      snake.forEach((s, i) => {
        const hue = 280 + (i * 3); // Neon Purple to Blue gradient
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.shadowBlur = i === 0 ? 20 : 10;
        ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;

        // Rounded rect for snake with internal gradient
        const r = 6;
        const spacing = i === 0 ? 1 : 2;
        const x = s.x * TILE + spacing;
        const y = s.y * TILE + spacing;
        const w = TILE - (spacing * 2);
        const h = TILE - (spacing * 2);

        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();

        // Eyes for head
        if (i === 0) {
          ctx.fillStyle = '#fff';
          // Directional Eyes
          let eyeX1, eyeY1, eyeX2, eyeY2;
          if (vel.x === 1) { eyeX1 = 0.7; eyeY1 = 0.3; eyeX2 = 0.7; eyeY2 = 0.7; }
          else if (vel.x === -1) { eyeX1 = 0.3; eyeY1 = 0.3; eyeX2 = 0.3; eyeY2 = 0.7; }
          else if (vel.y === 1) { eyeX1 = 0.3; eyeY1 = 0.7; eyeX2 = 0.7; eyeY2 = 0.7; }
          else { eyeX1 = 0.3; eyeY1 = 0.3; eyeX2 = 0.7; eyeY2 = 0.3; }

          ctx.beginPath();
          ctx.arc(x + w * eyeX1, y + h * eyeY1, 2.5, 0, Math.PI * 2);
          ctx.arc(x + w * eyeX2, y + h * eyeY2, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.shadowBlur = 0;

      // Draw Particles
      particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.shadowBlur = 5; ctx.shadowColor = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
      });
      particles = particles.filter(p => p.life > 0);
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function loop(time = performance.now()) {
      if (!active) return;
      if (!lastTime) lastTime = time;
      const dt = (time - lastTime) / 1000;
      lastTime = time;

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('keyup', e => {
      if (e.code === 'Space') tickRate = Math.max(0.06, 0.15 - (score / 2000));
    });

    resetGame(); // Start immediately
  </script>
</body>

</html>