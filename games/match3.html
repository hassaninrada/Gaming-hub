<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Candy Crush 2.0 | GameHub Pro</title>
  <link rel="stylesheet" href="../css/style.css">
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    .game-wrapper {
      max-width: 600px;
      margin: 40px auto;
      background: var(--card-bg);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 40px 100px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(20px);
      user-select: none;
    }

    .stats-bar {
      padding: 15px 40px;
      background: rgba(124, 77, 255, 0.1);
      display: flex;
      justify-content: space-around;
      font-size: 14px;
      font-weight: 800;
      border-bottom: 1px solid var(--glass-border);
    }

    .stat-val {
      color: var(--accent-secondary);
      margin-left: 5px;
      font-size: 18px;
    }

    .game-body {
      position: relative;
      background: #111;
      padding: 20px;
      display: flex;
      justify-content: center;
    }

    #grid {
      position: relative;
      width: 400px;
      height: 400px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 2px;
      border: 2px solid #333;
    }

    .gem {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .gem:hover {
      transform: scale(1.1);
      z-index: 10;
    }

    .gem.selected {
      box-shadow: 0 0 15px #fff;
      transform: scale(1.1);
      z-index: 20;
      border: 2px solid #fff;
    }

    .gem.match {
      animation: pop 0.3s forwards;
    }

    @keyframes pop {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.2);
        opacity: 1;
      }

      100% {
        transform: scale(0);
        opacity: 0;
      }
    }

    /* Gem Types */
    .gem-0 {
      background: radial-gradient(circle at 30% 30%, #ff0d72, #a60040);
      box-shadow: 0 0 10px #ff0d72;
      border-radius: 50%;
    }

    /* Circle Red */
    .gem-1 {
      background: linear-gradient(135deg, #0dc2ff, #0077a3);
      box-shadow: 0 0 10px #0dc2ff;
      border-radius: 4px;
    }

    /* Square Blue */
    .gem-2 {
      background: linear-gradient(45deg, #0dff72, #00a340);
      box-shadow: 0 0 10px #0dff72;
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    }

    /* Triangle Green */
    .gem-3 {
      background: radial-gradient(circle, #f538ff, #a300a3);
      box-shadow: 0 0 10px #f538ff;
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    }

    /* Diamond Purple */
    .gem-4 {
      background: linear-gradient(to bottom, #ff8e0d, #a35500);
      box-shadow: 0 0 10px #ff8e0d;
      clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
    }

    /* Trapezoid Orange */
    .gem-5 {
      background: radial-gradient(circle, #ffe138, #a38f00);
      box-shadow: 0 0 10px #ffe138;
      clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
    }

    /* Star/Pentagon Yellow */

    .overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      top: 0;
      left: 0;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
  </style>
</head>

<body class="dark-theme">
  <div class="bg-glow-container">
    <div class="glow-sphere sphere-1"></div>
    <div class="glow-sphere sphere-2"></div>
  </div>

  <header class="main-header" style="position: relative; background: transparent; border: none;">
    <div class="nav-container">
      <a href="../index.html" class="logo" style="text-decoration: none; color: inherit;">
        <i data-lucide="arrow-left"></i>
        <span>BACK TO <span class="accent-text">HUB</span></span>
      </a>
      <h2 style="font-weight:800; letter-spacing:-1px">NEON CANDY CRUSH</h2>
    </div>
  </header>

  <div class="game-wrapper">
    <div class="stats-bar">
      <span>SCORE: <span class="stat-val" id="score">0</span></span>
      <span>MOVES: <span class="stat-val" id="moves">20</span></span>
    </div>

    <div class="game-body">
      <div id="grid"></div>

      <div class="overlay" id="gameOverScreen">
        <h1 style="font-size:48px; margin-bottom:10px; color:var(--accent-primary)">FINISHED</h1>
        <p style="margin-bottom:20px; font-size:24px">SCORE: <span id="finalScore" style="color:#fff">0</span></p>
        <button class="btn-primary" onclick="initGame()">PLAY AGAIN</button>
      </div>
    </div>
  </div>

  <script src="../js/shared.js"></script>
  <script>
    lucide.createIcons();

    const gridEl = document.getElementById('grid');
    const rows = 8;
    const cols = 8;
    const types = 6;
    let grid = [];
    let selected = null;
    let score = 0;
    let moves = 20;
    let locking = false;

    function initGame() {
      score = 0; moves = 20;
      grid = [];
      gridEl.innerHTML = '';
      document.getElementById('gameOverScreen').style.display = 'none';
      updateUI();

      for (let r = 0; r < rows; r++) {
        let row = [];
        for (let c = 0; c < cols; c++) {
          let type = Math.floor(Math.random() * types);
          // Prevent initial matches (simple check)
          while ((c >= 2 && row[c - 1].type === type && row[c - 2].type === type) ||
            (r >= 2 && grid[r - 1][c].type === type && grid[r - 2][c].type === type)) {
            type = Math.floor(Math.random() * types);
          }

          let gem = document.createElement('div');
          gem.className = `gem gem-${type}`;
          gem.dataset.r = r; gem.dataset.c = c;
          gem.onclick = () => clickGem(r, c);

          gridEl.appendChild(gem);
          row.push({ type, el: gem });
        }
        grid.push(row);
      }
    }

    function updateUI() {
      document.getElementById('score').innerText = score;
      document.getElementById('moves').innerText = moves;
    }

    async function clickGem(r, c) {
      if (locking || moves <= 0) return;

      let gem = grid[r][c];

      if (!selected) {
        selected = { r, c, el: gem.el };
        gem.el.classList.add('selected');
        if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('click');
      } else {
        selected.el.classList.remove('selected');
        let sr = selected.r, sc = selected.c;
        selected = null;

        if (Math.abs(sr - r) + Math.abs(sc - c) === 1) {
          // Try Swap
          await swap(sr, sc, r, c);
          let valid = await checkMatches();
          if (!valid) {
            // Swap back
            await swap(sr, sc, r, c);
            if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('loss'); // Invalid move sound
          } else {
            moves--;
            updateUI();
            if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('move');

            // Cascade loop
            while (await fillHoles()) {
              await new Promise(r => setTimeout(r, 200));
              if (!await checkMatches()) break;
            }

            if (moves <= 0) {
              setTimeout(() => {
                document.getElementById('finalScore').innerText = score;
                document.getElementById('gameOverScreen').style.display = 'flex';
                if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('win');
              }, 500);
            }
          }
        } else {
          // Clicked far away, just select new
          if (sr !== r || sc !== c) {
            selected = { r, c, el: gem.el };
            gem.el.classList.add('selected');
          }
        }
      }
    }

    async function swap(r1, c1, r2, c2) {
      locking = true;
      // Visual swap
      let el1 = grid[r1][c1].el;
      let el2 = grid[r2][c2].el;

      // We actually just swap classNames for simplicity in DOM, but keep logic
      // Wait, animation requires transforms.
      // Simplified: Swap TYPES and ClassNames.

      let t1 = grid[r1][c1].type;
      let t2 = grid[r2][c2].type;

      grid[r1][c1].type = t2;
      grid[r2][c2].type = t1;

      el1.className = `gem gem-${t2}`;
      el2.className = `gem gem-${t1}`;

      await new Promise(r => setTimeout(r, 200));
      locking = false;
    }

    async function checkMatches() {
      let matched = [];

      // Horizontal
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols - 2; c++) {
          let t = grid[r][c].type;
          if (t === -1) continue;
          let matchLen = 1;
          while (c + matchLen < cols && grid[r][c + matchLen].type === t) matchLen++;
          if (matchLen >= 3) {
            for (let k = 0; k < matchLen; k++) matched.push({ r, c: c + k });
            c += matchLen - 1;
          }
        }
      }

      // Vertical
      for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows - 2; r++) {
          let t = grid[r][c].type;
          if (t === -1) continue;
          let matchLen = 1;
          while (r + matchLen < rows && grid[r + matchLen][c].type === t) matchLen++;
          if (matchLen >= 3) {
            for (let k = 0; k < matchLen; k++) matched.push({ r: r + k, c });
            r += matchLen - 1;
          }
        }
      }

      if (matched.length > 0) {
        // Unique
        let unique = [];
        matched.forEach(m => {
          if (!unique.some(u => u.r === m.r && u.c === m.c)) unique.push(m);
        });

        score += unique.length * 10;
        updateUI();

        // Animate removal
        unique.forEach(u => {
          grid[u.r][u.c].el.classList.add('match');
          grid[u.r][u.c].type = -1; // Empty
        });

        if (typeof GameHubAudio !== 'undefined') GameHubAudio.play('win');
        await new Promise(r => setTimeout(r, 300));

        // Clear DOM
        unique.forEach(u => {
          grid[u.r][u.c].el.classList.remove('match');
          grid[u.r][u.c].el.className = 'gem'; // invisible
        });

        return true;
      }
      return false;
    }

    async function fillHoles() {
      let moved = false;
      // Gravity
      for (let c = 0; c < cols; c++) {
        for (let r = rows - 1; r > 0; r--) {
          if (grid[r][c].type === -1) {
            // Find nearest above
            let nr = r - 1;
            while (nr >= 0 && grid[nr][c].type === -1) nr--;

            if (nr >= 0) {
              // Move down
              grid[r][c].type = grid[nr][c].type;
              grid[nr][c].type = -1;
              grid[r][c].el.className = `gem gem-${grid[r][c].type}`;
              grid[nr][c].el.className = 'gem';
              moved = true;
            } else {
              // Spawn new
              grid[r][c].type = Math.floor(Math.random() * types);
              grid[r][c].el.className = `gem gem-${grid[r][c].type}`;
              moved = true;
            }
          }
        }
        // Top row fill if empty
        if (grid[0][c].type === -1) {
          grid[0][c].type = Math.floor(Math.random() * types);
          grid[0][c].el.className = `gem gem-${grid[0][c].type}`;
          moved = true;
        }
      }
      return moved;
    }

    initGame();
  </script>
</body>

</html>